第三章 递归    

递归是很多算法都使用的一种编程方法，是理解本书后续内容的关键。  
将问题分成基线条件和递归条件。    
递归是一种优雅的问题解决方法。  
运行示例代码  
用纸笔逐步执行至少一个递归函数  
本章包含大量伪代码。  
伪代码是对手头问题的简要描述，  
看着像代码，其实更接近自然语言。    

递归只是让解决方案更清晰，容易理解    
并没有性能上的优势  
实际上，在有些情况下，使用循环的性能更好。  

 ## 基线条件和递归条件  
由于递归函数调用自己，  
因此编写这样的函数时很容易出错  
进而导致无限循环。     

所以编写递归函数时，  
必须告诉他何时停止递归。   

正因为如此，  
每个递归函数都有两部分：  
基线条件(base case)和递归条件(recursive case)。  
递归条件指的是 函数调用自己，  
而基线条件则指的是函数不再调用自己，  
从而避免形成无限循环。   

P33  
 ## 栈   

本节将介绍一个重要的编程概念---调用栈(call stack)     
调用栈不仅对编程来说很重要  
使用递归时，也必须理解这个概念。   

只有两种操作：     
压入（插入）    
弹出（删除并读取）   


 ### 调用栈  
调用另一个函数时，  
当前函数暂停并处于未完成状态。  

调用栈：  
用于存储多个函数的变量。  

 ### 递归调用栈   
使用栈虽然很方便，但是也要付出代价：  
存储详尽的信息可能占用大量的内存。   
每个函数调用都要占用一定的内存，  
如果栈很高，  
就意味着计算机存储了大量函数调用的信息。  

在这种情况下，有两种选择：  
重新编写代码，转而使用循环。     
使用尾递归。（不在本书讨论范围内）   

 # 第三章小结  
递归指的是调用自己的函数。  
每个递归都有两个条件：基线条件和递归条件。  
栈有两种操作：压入和弹出。    
所有函数调用都进入调用栈。   
调用栈可能很长，这将占用大量的内存。   

![image](https://user-images.githubusercontent.com/88927644/147392957-66dccd3b-aa07-4ac7-bfb5-9eb50f5cff47.png)
