第四章 快速排序   

分而治之 divide and conquer     

P47  
编写涉及数组的递归函数时，   
基线条件通常是数组为空，或只包含一个元素。   

P48  
最简单的数组就是根本不需要排序的数组。   

从数组中选择一个元素用作基准值(pivot)。    

分区(partitioning):     
找出比基准值小的元素和比基准值大的元素。  

现在有：  
一个小于基准值的子数组  
基准值  
一个大于基准值的子数组   

这里只是进行了分区，得到的两个子数组是无序的。   

如何对子数组进行排序？  
用快速排序       

P53  
通常不考虑算法运行时间前面的常量，  
因为如果两种算法的大O运行时间不同，   
这种常量将无关紧要。 
  
对于简单查找和二分查找来说，    
常量几乎没什么影响。  

但有时候，常量的影响很大，如：快速查找和合并查找。    
因为他们的运行时间一样，所以前面的常量小的会速度快。   

P54   
 ## 平均情况和最糟情况     
快速排序的性能高度依赖于你选择的基准值。  

如果将中间的元素用作基准值，调用栈会短得多，  
所以不需要那么多递归调用，  
很快就到达了基线条件。

最佳情况也是平均情况。   
只要你每次都随机地选择一个数组元素作为基准值。    

快速排序是最快的排序算法之一，也是D&C典范。   

 # 第四章小结   
D&C将问题逐步分解。  
使用D&C处理列表时，  
基线条件很可能是空数组或只包含一个元素的数组。  
实现快速排序时，请随机地选择用作基准值的元素。  
快速排序的平均运行时间为O(n log n)。   
大O表示法中的常量有时候事关重大，  
这就是快速排序比合并排序快的原因所在。   
比较简单查找和二分查找时，常量几乎无关紧要，   
因为列表很长时，O(log n)的速度比O(n)快得多。   

![image](https://user-images.githubusercontent.com/88927644/147413717-2fae906c-b0ff-4be3-8288-2096f0fd5a18.png)

